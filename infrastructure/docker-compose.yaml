name: dagster

# Postgres variables, used in both the postgres container for configuration,
# and in the dagster services for connecting to the postgres container.
# The variable names are the same in both thanks to the dagster.yaml
# configuration file specifying such.
x-postgres-variables: &postgres-variables
  POSTGRES_USER: ${POSTGRES_USER:-dagster_user}
  POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-dagster_password}
  POSTGRES_DB: ${POSTGRES_DB:-dagster_db}
  POSTGRES_HOST: "dagster-postgres"

x-dagster-configs: &dagster-configs
  - source: dagster.yaml
    target: /opt/dagster/home/dagster.yaml
  - source: workspace.yaml
    target: /opt/dagster/home/workspace.yaml


services:
  # This service runs the postgres DB used by dagster for run storage, schedule storage,
  # and event log storage. Depending on the hardware you run this Compose on, you may be able
  # to reduce the interval and timeout in the healthcheck to speed up your `docker-compose up` times.
  dagster-postgres:
    image: postgres:16
    container_name: dagster-postgres
    environment:
      <<: *postgres-variables
      PGDATA: "/var/lib/postgresql/data"
    volumes:
      - dagster-pgdata-vol:/var/lib/postgresql/data
    networks: ["dagster-network"]
    healthcheck:
      test: pg_isready -U $$POSTGRES_USER -d $$POSTGRES_DB
      interval: 10s
      timeout: 8s
      retries: 5

  # This service runs the gRPC server that loads user code, used by both dagster-webserver
  # and dagster-daemon. By setting DAGSTER_CURRENT_IMAGE to its own image, we tell the
  # run launcher to use this same image when launching runs in a new container as well.
  dagster-codeserver:
    container_name: dagster-codeserver
    image: ghcr.io/openclimatefix/dagster-dags:latest
    restart: always
    pull_policy: always
    environment:
      <<: *postgres-variables
      DAGSTER_CURRENT_IMAGE: "ghcr.io/openclimatefix/dagster-dags"
      DAGSTER_HOME: "/opt/dagster/home"
    volumes:
      - /mnt/storage_a/dagster:/opt/dagster/local # LocalArtifactStorage base_dir
      - /var/run/docker.sock:/var/run/docker.sock # To allow launching docker Pipes
    configs: *dagster-configs
    networks: ["dagster-network"]

  # This service runs dagster-webserver, which loads your user code from the user code container.
  # Since our instance uses the QueuedRunCoordinator, any runs submitted from the webserver will be put on
  # a queue and later dequeued and launched by dagster-daemon.
  dagster-webserver:
    container_name: dagster-webserver
    image: dagster/dagster-k8s:latest
    command: ["dagster-webserver", "-h", "0.0.0.0", "-p", "3008", "-w", "/opt/dagster/home/workspace.yaml"]
    post_start:
      - command: ["pip", "install", "dagster-docker"] # Required for using dagster_docker Pipes
    ports:
      - "3008:3008"
    environment:
      <<: *postgres-variables
      DAGSTER_HOME: "/opt/dagster/home"
    configs: *dagster-configs
    volumes:
      # Enable termination of runs from the webserver
      - /var/run/docker.sock:/var/run/docker.sock
      - /tmp/io_manager_storage:/tmp/io_manager_storage
    networks: ["dagster-network"]
    depends_on:
      dagster-postgres:
        condition: service_healthy
      dagster-codeserver:
        condition: service_started

  # This service runs the dagster-daemon process, which is responsible for taking runs
  # off of the queue and launching them, as well as creating runs from schedules or sensors.
  dagster-daemon:
    container_name: dagster-daemon
    image: dagster/dagster-k8s:latest
    command: ["dagster-daemon", "run", "-w", "/opt/dagster/home/workspace.yaml"]
    post_start:
      - command: ["pip", "install", "dagster-docker"] # Required for using dagster_docker Pipes
    restart: on-failure
    environment:
      <<: *postgres-variables
      DAGSTER_HOME: "/opt/dagster/home"
    configs: *dagster-configs
    volumes:
      # Enable kicking off of runs from the daemon
      - /var/run/docker.sock:/var/run/docker.sock
      - /tmp/io_manager_storage:/tmp/io_manager_storage
    networks: ["dagster-network"]
    depends_on:
      dagster-postgres:
        condition: service_healthy
      dagster-codeserver:
        condition: service_started

networks:
  dagster-network:
    driver: bridge
    name: dagster-network

volumes:
  # Volume for the postgres data directory
  dagster-pgdata-vol:
    name: dagster-pgdata-vol

configs:
  workspace.yaml:
    content: |
      load_from:
        - grpc_server:
            host: "dagster-codeserver"
            port: 4266
            location_name: "dagster_dags"

  dagster.yaml:
    content: |
      storage:
        postgres:
          postgres_db:
            username: {"env": "POSTGRES_USER"}
            password: {"env": "POSTGRES_PASSWORD"}
            hostname: {"env": "POSTGRES_HOST"}
            db_name: {"env": "POSTGRES_DB"}
            port: 5432

      local_artifact_storage:
        module: dagster.core.storage.root
        class: LocalArtifactStorage
        config:
          base_dir: "/opt/dagster/local/"

      run_coordinator:
        module: dagster.core.run_coordinator
        class: QueuedRunCoordinator
        config:
          max_concurrent_runs: 30
          tag_concurrency_limits:
            - key: "dagster/backfill"
              limit: 15
            - key: "nwp-consumer"
              limit: 1

      run_launcher:
        module: dagster_docker
        class: DockerRunLauncher
        config:
          env_vars:
            - POSTGRES_USER
            - POSTGRES_PASSWORD
            - POSTGRES_DB
            - POSTGRES_HOST

      retention:
        schedule:
          purge_after_days: 90
        sensor:
          purge_after_days:
            skipped: 7
            failure: 30
            success: -1

